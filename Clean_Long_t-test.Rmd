---
title: "Proteomics Data Analysis Tutorial"
author: "Generated by ChatGPT"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# SECTION 1: Load Required Libraries

```{r}
library(readxl)     # Read Excel files
library(dplyr)      # Data wrangling
library(stringr)    # String operations
library(tidyr)      # Reshaping data
library(httr)       # HTTP requests
library(jsonlite)   # JSON parsing
library(purrr)      # Functional programming
```

`library(readxl)` 
- loads the `readxl` package allowing `.xlsx` files to be imported from excel and allows `read_excel()` function.

`library(dplyr)`
- loads the `dplyr` package allowing for data wrangling and manipulation/transformation techniques with functions like `mutate()`, `filter()`, `select()`, `group_by()`, and `summarize()`.

`library(stingr)`
- loads the `stingr` package that allows for string manipulations via functions like `str_extract()`, `str_remove()`, `str_detect()`.

`library(tidyr)`
- loads the `tidyr` package which allows reshaping of data into or from wide to long format with functions like `pivot_longer()` or `pivot_shorter()`.

`library(httr)`
- loads the `httr` package which enables requests to APIs which will be used later for reproducible querying of UniProt API with functions like `GET()`.

`library(jsonlite)`
- loads `jsonelite` package for turning JSON responses into R-readable data frames or lists with functions like `content(..., as = "parsed", type = "application/json")`.

`library(purrr)`
- loads `purrr` package to allow functions to be mapped or applied acorss a vector and have combined results with fuctions like `map_dfr()`.

# SECTION 2: Load & Clean Data

```{r}
sarco <- read_excel("13_MASTER_SEER proteome analysis (4-4-23).xlsx", sheet = "MASTER_SARCO_data") %>%
  select(where(~ any(!is.na(.)))) %>%
  filter(if_any(everything(), ~ !is.na(.))) %>%
  mutate(
    Gene_Symbol = str_extract(Gene_protein, "^[^_;]+") %>% str_remove(";?GN=+$"),
    Accession   = str_extract(Gene_protein, "\\b[A-Z][0-9][A-Z0-9]{3}[0-9]\\b")
  )
```

`sarco <- read_excel("13_MASTER_SEER proteome analysis (4-4-23).xlsx", sheet = "MASTER_SARCO_data")`
- reads the excel spreadsheet and specific sheet with arguments like "13_MASTER_SEER proteome analysis (4-4-23).xlsx" as the file path, and "sheet = "MASTER_SARCO_data" which specifies the sheet to load.
- a `tibble` is returned with proteomic data

`%>% select(where(~any(!is.na(.))))`
- function `select()` is used to select for columns with `where(~any(!is.na(.)))` which is an argument that specifies columns that have at least one non-NA value are selected. Thus, empty columns are removed.
  - `~` is used to create a transient "anonymous" function.
  - `!is.na(.)` is used as a logical operator to check for there *not* being any missing values for a current column (`.`).
  
`%>% filter(if_any(everything(), ~ !is.na(.)))` 
- function `filter()` is used to select for rows with `if_any(everything(), ~ !is.na(.))` argument which specifies the rows where at least one column is non-NA are kept. Thus, empty rows are removed.
  - this function pertains more to this current data frame given that some rows are indeed empty
  
`mutate(...)`
- this function creates 2 new columns: 1) Gene_Symbol & 2) Accession. These are extracted using `str_extract()`, `str_remove`, and `Regex` logic.
  1) 
  2) 
# SECTION 3: Identify Sample Columns and Calculate Detection Score

```{r}
sample_cols <- grep("^(EAA|PRE|POST|PPS)", names(sarco), value = TRUE)
sarco <- sarco %>% mutate(detection_score = rowSums(across(all_of(sample_cols)), na.rm = TRUE))

```



# SECTION 4: Query UniProt for Missing Gene Symbols

```{r}
# Step 1: Find Missing Gene Symbols
accessions_to_query <- sarco %>%
  group_by(Accession, Gene_Symbol) %>%
  slice_max(detection_score, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  filter(is.na(Gene_Symbol) | Gene_Symbol == "") %>%
  pull(Accession) %>% unique() %>% na.omit()
```


```{r}
# Step 2: Define the Query Function
query_uniprot <- function(accessions) {
  url <- "https://rest.uniprot.org/uniprotkb/search"
  q <- paste(accessions, collapse = " OR ")
  r <- GET(url, query = list(query = q, fields = "accession,gene_primary", format = "json", size = 500))
  if (status_code(r) == 200) {
    j <- content(r, as = "parsed", type = "application/json")
    tibble(
      Accession = sapply(j$results, function(x) x$primaryAccession),
      Gene_Symbol_API = sapply(j$results, function(x)
        if (!is.null(x$genes[[1]]$geneName$value)) x$genes[[1]]$geneName$value else NA_character_)
    )
  } else stop("UniProt query failed")
}
```


```{r}
# Step 3: Run the Query on Batches
uniprot_results <- accessions_to_query %>%
  split(ceiling(seq_along(.) / 100)) %>%
  map_dfr(query_uniprot) %>%
  distinct(Accession, .keep_all = TRUE)
```


# 5. Convert to Long Format

```{r}
long_df <- sarco_clean %>%
  select(-matches("^T-test_|^DELTA_|^CORREL_|^Young_|^detection_")) %>%
  pivot_longer(cols = all_of(sample_cols), names_to = "Sample", values_to = "Abundance") %>%
  mutate(
    Timepoint = case_when(
      str_detect(Sample, "PRE") ~ "Pre",
      str_detect(Sample, "POST") ~ "Post",
      TRUE ~ NA_character_
    ),
    Group = case_when(
      str_detect(Sample, "EAA|PPS") ~ "Young",
      TRUE ~ "MA"
    )
  )

# Full version with all statistical columns included
long_df_full <- sarco_clean %>%
  pivot_longer(cols = all_of(sample_cols), names_to = "Sample", values_to = "Abundance") %>%
  mutate(
    Timepoint = case_when(
      str_detect(Sample, "PRE") ~ "Pre",
      str_detect(Sample, "POST") ~ "Post",
      TRUE ~ NA_character_
    ),
    Group = case_when(
      str_detect(Sample, "EAA|PPS") ~ "Young",
      TRUE ~ "MA"
    )
  )

write.csv(long_df, "Clean_Long2.csv", row.names = FALSE)
write.csv(sarco_clean, "Clean_Wide2.csv", row.names = FALSE)
```

- pivot_longer() reshapes sample columns into rows.

- case_when() = like if...else if...else for assigning new values to a column.

# 6. Perform T-Tests

Each t-test block:

- Filters gene-specific abundance vectors for each group.

- Runs t.test() (Welch's unpaired t-test by default).

- Saves mean, change, and p-value.

```{r}
results1 <- intersect(
  unique(long_df$Gene_Symbol[long_df$Group == "Young"]),
  unique(long_df$Gene_Symbol[long_df$Timepoint == "Pre"])
) %>%
  map_dfr(function(gene) {
    y <- long_df %>% filter(Group == "Young", Gene_Symbol == gene) %>% pull(Abundance)
    pre <- long_df %>% filter(Group == "MA", Timepoint == "Pre", Gene_Symbol == gene) %>% pull(Abundance)
    if (length(y) > 1 && length(pre) > 1) {
      t <- t.test(y, pre)
      tibble(Gene_Symbol = gene, Young_Mean = mean(y), Pre_MA_Mean = mean(pre),
             Change = mean(pre) - mean(y), p_value = t$p.value)
    }
  })

results2 <- intersect(
  unique(long_df$Gene_Symbol[long_df$Timepoint == "Pre"]),
  unique(long_df$Gene_Symbol[long_df$Timepoint == "Post"])
) %>%
  map_dfr(function(gene) {
    pre <- long_df %>% filter(Group == "MA", Timepoint == "Pre", Gene_Symbol == gene) %>% pull(Abundance)
    post <- long_df %>% filter(Group == "MA", Timepoint == "Post", Gene_Symbol == gene) %>% pull(Abundance)
    if (length(pre) > 1 && length(post) > 1) {
      t <- t.test(pre, post)
      tibble(Gene_Symbol = gene, Pre_MA_Mean = mean(pre), Post_MA_Mean = mean(post),
             Change = mean(post) - mean(pre), p_value = t$p.value)
    }
  })
```

# 7. Full T-Tests (with detection/correlation retained)

```{r}
results1_full <- intersect(
  unique(long_df_full$Gene_Symbol[long_df_full$Group == "Young"]),
  unique(long_df_full$Gene_Symbol[long_df_full$Timepoint == "Pre"])
) %>%
  map_dfr(function(gene) {
    y <- long_df_full %>% filter(Group == "Young", Gene_Symbol == gene) %>% pull(Abundance)
    pre <- long_df_full %>% filter(Group == "MA", Timepoint == "Pre", Gene_Symbol == gene) %>% pull(Abundance)
    if (length(y) > 1 && length(pre) > 1) {
      t <- t.test(y, pre)
      tibble(Gene_Symbol = gene, Young_Mean = mean(y), Pre_MA_Mean = mean(pre),
             Change = mean(pre) - mean(y), p_value = t$p.value)
    }
  })

results2_full <- intersect(
  unique(long_df_full$Gene_Symbol[long_df_full$Timepoint == "Pre"]),
  unique(long_df_full$Gene_Symbol[long_df_full$Timepoint == "Post"])
) %>%
  map_dfr(function(gene) {
    pre <- long_df_full %>% filter(Group == "MA", Timepoint == "Pre", Gene_Symbol == gene) %>% pull(Abundance)
    post <- long_df_full %>% filter(Group == "MA", Timepoint == "Post", Gene_Symbol == gene) %>% pull(Abundance)
    if (length(pre) > 1 && length(post) > 1) {
      t <- t.test(pre, post)
      tibble(Gene_Symbol = gene, Pre_MA_Mean = mean(pre), Post_MA_Mean = mean(post),
             Change = mean(post) - mean(pre), p_value = t$p.value)
    }
  })
```

---
